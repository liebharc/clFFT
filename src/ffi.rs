use ocl::ffi::{cl_int, cl_uint, cl_bool, cl_ulong, cl_char, cl_ushort, cl_long, cl_uchar,
               cl_float, cl_short, cl_double, 
               cl_kernel, cl_program, cl_profiling_info, cl_mem, cl_event, cl_command_queue,
               cl_context, cl_map_flags, cl_device_id, cl_program_build_info, cl_sampler_info,
               cl_program_info, cl_sampler, cl_kernel_info, cl_kernel_work_group_info,
               cl_event_info, cl_channel_order, cl_channel_type, cl_platform_id,
               cl_platform_info, cl_device_type, cl_context_properties, cl_context_info,
               cl_image_format, cl_mem_flags, cl_image_info, cl_mem_info, cl_filter_mode,
               cl_buffer_create_type, cl_command_queue_info, cl_mem_object_type, cl_device_info, cl_command_queue_properties, cl_addressing_mode};

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const CL_CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const CL_SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const CL_SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const CL_CHAR_MAX: ::std::os::raw::c_uint = 127;
pub const CL_CHAR_MIN: ::std::os::raw::c_int = -128;
pub const CL_UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const CL_SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const CL_SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const CL_USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const CL_INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const CL_INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const CL_UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const CL_FLT_DIG: ::std::os::raw::c_uint = 6;
pub const CL_FLT_MANT_DIG: ::std::os::raw::c_uint = 24;
pub const CL_FLT_MAX_10_EXP: ::std::os::raw::c_uint = 38;
pub const CL_FLT_MAX_EXP: ::std::os::raw::c_uint = 128;
pub const CL_FLT_MIN_10_EXP: ::std::os::raw::c_int = -37;
pub const CL_FLT_MIN_EXP: ::std::os::raw::c_int = -125;
pub const CL_FLT_RADIX: ::std::os::raw::c_uint = 2;
pub const CL_FLT_MAX: f32 = 340282346638528860000000000000000000000.;
pub const CL_DBL_DIG: ::std::os::raw::c_uint = 15;
pub const CL_DBL_MANT_DIG: ::std::os::raw::c_uint = 53;
pub const CL_DBL_MAX_10_EXP: ::std::os::raw::c_uint = 308;
pub const CL_DBL_MAX_EXP: ::std::os::raw::c_uint = 1024;
pub const CL_DBL_MIN_10_EXP: ::std::os::raw::c_int = -307;
pub const CL_DBL_MIN_EXP: ::std::os::raw::c_int = -1021;
pub const CL_DBL_RADIX: ::std::os::raw::c_uint = 2;
pub const CL_DBL_MAX: f32 =
    179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.;
pub const CL_M_E: f32 = 2.718281828459045;
pub const CL_M_LOG2E: f32 = 1.4426950408889634;
pub const CL_M_LOG10E: f32 = 0.4342944819032518;
pub const CL_M_LN2: f32 = 0.6931471805599453;
pub const CL_M_LN10: f32 = 2.302585092994046;
pub const CL_M_PI: f32 = 3.141592653589793;
pub const CL_M_PI_2: f32 = 1.5707963267948966;
pub const CL_M_PI_4: f32 = 0.7853981633974483;
pub const CL_M_1_PI: f32 = 0.3183098861837907;
pub const CL_M_2_PI: f32 = 0.6366197723675814;
pub const CL_M_2_SQRTPI: f32 = 1.1283791670955126;
pub const CL_M_SQRT2: f32 = 1.4142135623730951;
pub const CL_M_SQRT1_2: f32 = 0.7071067811865476;
pub const CL_M_E_F: f32 = 2.71828174591064;
pub const CL_M_LOG2E_F: f32 = 1.44269502162933;
pub const CL_M_LOG10E_F: f32 = 0.4342944920063;
pub const CL_M_LN2_F: f32 = 0.6931471824646;
pub const CL_M_LN10_F: f32 = 2.30258512496948;
pub const CL_M_PI_F: f32 = 3.14159274101257;
pub const CL_M_PI_2_F: f32 = 1.57079637050629;
pub const CL_M_PI_4_F: f32 = 0.78539818525314;
pub const CL_M_1_PI_F: f32 = 0.31830987334251;
pub const CL_M_2_PI_F: f32 = 0.63661974668503;
pub const CL_M_2_SQRTPI_F: f32 = 1.1283792257309;
pub const CL_M_SQRT2_F: f32 = 1.41421353816986;
pub const CL_M_SQRT1_2_F: f32 = 0.70710676908493;
pub const CL_MAXFLOAT: f32 = 340282346638528860000000000000000000000.;
pub const _MAX_PATH: ::std::os::raw::c_uint = 260;
pub const _MAX_FNAME: ::std::os::raw::c_uint = 256;
pub const _MAX_EXT: ::std::os::raw::c_uint = 256;
pub const _MAX_DRIVE: ::std::os::raw::c_uint = 3;
pub const _MAX_DIR: ::std::os::raw::c_uint = 256;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const RAND_MAX: ::std::os::raw::c_uint = 32767;
pub const _OUT_TO_DEFAULT: ::std::os::raw::c_uint = 0;
pub const _OUT_TO_STDERR: ::std::os::raw::c_uint = 1;
pub const _OUT_TO_MSGBOX: ::std::os::raw::c_uint = 2;
pub const _REPORT_ERRMODE: ::std::os::raw::c_uint = 3;
pub const _MM_HINT_T0: ::std::os::raw::c_uint = 3;
pub const _MM_HINT_T1: ::std::os::raw::c_uint = 2;
pub const _MM_HINT_T2: ::std::os::raw::c_uint = 1;
pub const _MM_HINT_NTA: ::std::os::raw::c_uint = 0;
pub const _MM_EXCEPT_INVALID: ::std::os::raw::c_uint = 1;
pub const _MM_EXCEPT_DENORM: ::std::os::raw::c_uint = 2;
pub const _MM_EXCEPT_DIV_ZERO: ::std::os::raw::c_uint = 4;
pub const _MM_EXCEPT_OVERFLOW: ::std::os::raw::c_uint = 8;
pub const _MM_EXCEPT_UNDERFLOW: ::std::os::raw::c_uint = 16;
pub const _MM_EXCEPT_INEXACT: ::std::os::raw::c_uint = 32;
pub const _MM_EXCEPT_MASK: ::std::os::raw::c_uint = 63;
pub const _MM_MASK_INVALID: ::std::os::raw::c_uint = 128;
pub const _MM_MASK_DENORM: ::std::os::raw::c_uint = 256;
pub const _MM_MASK_DIV_ZERO: ::std::os::raw::c_uint = 512;
pub const _MM_MASK_OVERFLOW: ::std::os::raw::c_uint = 1024;
pub const _MM_MASK_UNDERFLOW: ::std::os::raw::c_uint = 2048;
pub const _MM_MASK_INEXACT: ::std::os::raw::c_uint = 4096;
pub const _MM_MASK_MASK: ::std::os::raw::c_uint = 8064;
pub const _MM_ROUND_NEAREST: ::std::os::raw::c_uint = 0;
pub const _MM_ROUND_DOWN: ::std::os::raw::c_uint = 8192;
pub const _MM_ROUND_UP: ::std::os::raw::c_uint = 16384;
pub const _MM_ROUND_TOWARD_ZERO: ::std::os::raw::c_uint = 24576;
pub const _MM_ROUND_MASK: ::std::os::raw::c_uint = 24576;
pub const _MM_FLUSH_ZERO_MASK: ::std::os::raw::c_uint = 32768;
pub const _MM_FLUSH_ZERO_ON: ::std::os::raw::c_uint = 32768;
pub const _MM_FLUSH_ZERO_OFF: ::std::os::raw::c_uint = 0;
pub const __CL_FLOAT4__: ::std::os::raw::c_uint = 1;
pub const __CL_UCHAR16__: ::std::os::raw::c_uint = 1;
pub const __CL_CHAR16__: ::std::os::raw::c_uint = 1;
pub const __CL_USHORT8__: ::std::os::raw::c_uint = 1;
pub const __CL_SHORT8__: ::std::os::raw::c_uint = 1;
pub const __CL_INT4__: ::std::os::raw::c_uint = 1;
pub const __CL_UINT4__: ::std::os::raw::c_uint = 1;
pub const __CL_ULONG2__: ::std::os::raw::c_uint = 1;
pub const __CL_LONG2__: ::std::os::raw::c_uint = 1;
pub const __CL_DOUBLE2__: ::std::os::raw::c_uint = 1;
pub const __CL_UCHAR8__: ::std::os::raw::c_uint = 1;
pub const __CL_CHAR8__: ::std::os::raw::c_uint = 1;
pub const __CL_USHORT4__: ::std::os::raw::c_uint = 1;
pub const __CL_SHORT4__: ::std::os::raw::c_uint = 1;
pub const __CL_INT2__: ::std::os::raw::c_uint = 1;
pub const __CL_UINT2__: ::std::os::raw::c_uint = 1;
pub const __CL_ULONG1__: ::std::os::raw::c_uint = 1;
pub const __CL_LONG1__: ::std::os::raw::c_uint = 1;
pub const __CL_FLOAT2__: ::std::os::raw::c_uint = 1;
pub const CL_SUCCESS: ::std::os::raw::c_uint = 0;
pub const CL_DEVICE_NOT_FOUND: ::std::os::raw::c_int = -1;
pub const CL_DEVICE_NOT_AVAILABLE: ::std::os::raw::c_int = -2;
pub const CL_COMPILER_NOT_AVAILABLE: ::std::os::raw::c_int = -3;
pub const CL_MEM_OBJECT_ALLOCATION_FAILURE: ::std::os::raw::c_int = -4;
pub const CL_OUT_OF_RESOURCES: ::std::os::raw::c_int = -5;
pub const CL_OUT_OF_HOST_MEMORY: ::std::os::raw::c_int = -6;
pub const CL_PROFILING_INFO_NOT_AVAILABLE: ::std::os::raw::c_int = -7;
pub const CL_MEM_COPY_OVERLAP: ::std::os::raw::c_int = -8;
pub const CL_IMAGE_FORMAT_MISMATCH: ::std::os::raw::c_int = -9;
pub const CL_IMAGE_FORMAT_NOT_SUPPORTED: ::std::os::raw::c_int = -10;
pub const CL_BUILD_PROGRAM_FAILURE: ::std::os::raw::c_int = -11;
pub const CL_MAP_FAILURE: ::std::os::raw::c_int = -12;
pub const CL_MISALIGNED_SUB_BUFFER_OFFSET: ::std::os::raw::c_int = -13;
pub const CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST: ::std::os::raw::c_int
          =
    -14;
pub const CL_INVALID_VALUE: ::std::os::raw::c_int = -30;
pub const CL_INVALID_DEVICE_TYPE: ::std::os::raw::c_int = -31;
pub const CL_INVALID_PLATFORM: ::std::os::raw::c_int = -32;
pub const CL_INVALID_DEVICE: ::std::os::raw::c_int = -33;
pub const CL_INVALID_CONTEXT: ::std::os::raw::c_int = -34;
pub const CL_INVALID_QUEUE_PROPERTIES: ::std::os::raw::c_int = -35;
pub const CL_INVALID_COMMAND_QUEUE: ::std::os::raw::c_int = -36;
pub const CL_INVALID_HOST_PTR: ::std::os::raw::c_int = -37;
pub const CL_INVALID_MEM_OBJECT: ::std::os::raw::c_int = -38;
pub const CL_INVALID_IMAGE_FORMAT_DESCRIPTOR: ::std::os::raw::c_int = -39;
pub const CL_INVALID_IMAGE_SIZE: ::std::os::raw::c_int = -40;
pub const CL_INVALID_SAMPLER: ::std::os::raw::c_int = -41;
pub const CL_INVALID_BINARY: ::std::os::raw::c_int = -42;
pub const CL_INVALID_BUILD_OPTIONS: ::std::os::raw::c_int = -43;
pub const CL_INVALID_PROGRAM: ::std::os::raw::c_int = -44;
pub const CL_INVALID_PROGRAM_EXECUTABLE: ::std::os::raw::c_int = -45;
pub const CL_INVALID_KERNEL_NAME: ::std::os::raw::c_int = -46;
pub const CL_INVALID_KERNEL_DEFINITION: ::std::os::raw::c_int = -47;
pub const CL_INVALID_KERNEL: ::std::os::raw::c_int = -48;
pub const CL_INVALID_ARG_INDEX: ::std::os::raw::c_int = -49;
pub const CL_INVALID_ARG_VALUE: ::std::os::raw::c_int = -50;
pub const CL_INVALID_ARG_SIZE: ::std::os::raw::c_int = -51;
pub const CL_INVALID_KERNEL_ARGS: ::std::os::raw::c_int = -52;
pub const CL_INVALID_WORK_DIMENSION: ::std::os::raw::c_int = -53;
pub const CL_INVALID_WORK_GROUP_SIZE: ::std::os::raw::c_int = -54;
pub const CL_INVALID_WORK_ITEM_SIZE: ::std::os::raw::c_int = -55;
pub const CL_INVALID_GLOBAL_OFFSET: ::std::os::raw::c_int = -56;
pub const CL_INVALID_EVENT_WAIT_LIST: ::std::os::raw::c_int = -57;
pub const CL_INVALID_EVENT: ::std::os::raw::c_int = -58;
pub const CL_INVALID_OPERATION: ::std::os::raw::c_int = -59;
pub const CL_INVALID_GL_OBJECT: ::std::os::raw::c_int = -60;
pub const CL_INVALID_BUFFER_SIZE: ::std::os::raw::c_int = -61;
pub const CL_INVALID_MIP_LEVEL: ::std::os::raw::c_int = -62;
pub const CL_INVALID_GLOBAL_WORK_SIZE: ::std::os::raw::c_int = -63;
pub const CL_VERSION_1_0: ::std::os::raw::c_uint = 1;
pub const CL_VERSION_1_1: ::std::os::raw::c_uint = 1;
pub const CL_FALSE: ::std::os::raw::c_uint = 0;
pub const CL_TRUE: ::std::os::raw::c_uint = 1;
pub const CL_PLATFORM_PROFILE: ::std::os::raw::c_uint = 2304;
pub const CL_PLATFORM_VERSION: ::std::os::raw::c_uint = 2305;
pub const CL_PLATFORM_NAME: ::std::os::raw::c_uint = 2306;
pub const CL_PLATFORM_VENDOR: ::std::os::raw::c_uint = 2307;
pub const CL_PLATFORM_EXTENSIONS: ::std::os::raw::c_uint = 2308;
pub const CL_DEVICE_TYPE_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CL_DEVICE_TYPE_CPU: ::std::os::raw::c_uint = 2;
pub const CL_DEVICE_TYPE_GPU: ::std::os::raw::c_uint = 4;
pub const CL_DEVICE_TYPE_ACCELERATOR: ::std::os::raw::c_uint = 8;
pub const CL_DEVICE_TYPE_ALL: ::std::os::raw::c_uint = 4294967295;
pub const CL_DEVICE_TYPE: ::std::os::raw::c_uint = 4096;
pub const CL_DEVICE_VENDOR_ID: ::std::os::raw::c_uint = 4097;
pub const CL_DEVICE_MAX_COMPUTE_UNITS: ::std::os::raw::c_uint = 4098;
pub const CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: ::std::os::raw::c_uint = 4099;
pub const CL_DEVICE_MAX_WORK_GROUP_SIZE: ::std::os::raw::c_uint = 4100;
pub const CL_DEVICE_MAX_WORK_ITEM_SIZES: ::std::os::raw::c_uint = 4101;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR: ::std::os::raw::c_uint =
    4102;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT: ::std::os::raw::c_uint =
    4103;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT: ::std::os::raw::c_uint = 4104;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG: ::std::os::raw::c_uint =
    4105;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT: ::std::os::raw::c_uint =
    4106;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE: ::std::os::raw::c_uint =
    4107;
pub const CL_DEVICE_MAX_CLOCK_FREQUENCY: ::std::os::raw::c_uint = 4108;
pub const CL_DEVICE_ADDRESS_BITS: ::std::os::raw::c_uint = 4109;
pub const CL_DEVICE_MAX_READ_IMAGE_ARGS: ::std::os::raw::c_uint = 4110;
pub const CL_DEVICE_MAX_WRITE_IMAGE_ARGS: ::std::os::raw::c_uint = 4111;
pub const CL_DEVICE_MAX_MEM_ALLOC_SIZE: ::std::os::raw::c_uint = 4112;
pub const CL_DEVICE_IMAGE2D_MAX_WIDTH: ::std::os::raw::c_uint = 4113;
pub const CL_DEVICE_IMAGE2D_MAX_HEIGHT: ::std::os::raw::c_uint = 4114;
pub const CL_DEVICE_IMAGE3D_MAX_WIDTH: ::std::os::raw::c_uint = 4115;
pub const CL_DEVICE_IMAGE3D_MAX_HEIGHT: ::std::os::raw::c_uint = 4116;
pub const CL_DEVICE_IMAGE3D_MAX_DEPTH: ::std::os::raw::c_uint = 4117;
pub const CL_DEVICE_IMAGE_SUPPORT: ::std::os::raw::c_uint = 4118;
pub const CL_DEVICE_MAX_PARAMETER_SIZE: ::std::os::raw::c_uint = 4119;
pub const CL_DEVICE_MAX_SAMPLERS: ::std::os::raw::c_uint = 4120;
pub const CL_DEVICE_MEM_BASE_ADDR_ALIGN: ::std::os::raw::c_uint = 4121;
pub const CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE: ::std::os::raw::c_uint = 4122;
pub const CL_DEVICE_SINGLE_FP_CONFIG: ::std::os::raw::c_uint = 4123;
pub const CL_DEVICE_GLOBAL_MEM_CACHE_TYPE: ::std::os::raw::c_uint = 4124;
pub const CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE: ::std::os::raw::c_uint = 4125;
pub const CL_DEVICE_GLOBAL_MEM_CACHE_SIZE: ::std::os::raw::c_uint = 4126;
pub const CL_DEVICE_GLOBAL_MEM_SIZE: ::std::os::raw::c_uint = 4127;
pub const CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE: ::std::os::raw::c_uint = 4128;
pub const CL_DEVICE_MAX_CONSTANT_ARGS: ::std::os::raw::c_uint = 4129;
pub const CL_DEVICE_LOCAL_MEM_TYPE: ::std::os::raw::c_uint = 4130;
pub const CL_DEVICE_LOCAL_MEM_SIZE: ::std::os::raw::c_uint = 4131;
pub const CL_DEVICE_ERROR_CORRECTION_SUPPORT: ::std::os::raw::c_uint = 4132;
pub const CL_DEVICE_PROFILING_TIMER_RESOLUTION: ::std::os::raw::c_uint = 4133;
pub const CL_DEVICE_ENDIAN_LITTLE: ::std::os::raw::c_uint = 4134;
pub const CL_DEVICE_AVAILABLE: ::std::os::raw::c_uint = 4135;
pub const CL_DEVICE_COMPILER_AVAILABLE: ::std::os::raw::c_uint = 4136;
pub const CL_DEVICE_EXECUTION_CAPABILITIES: ::std::os::raw::c_uint = 4137;
pub const CL_DEVICE_QUEUE_PROPERTIES: ::std::os::raw::c_uint = 4138;
pub const CL_DEVICE_NAME: ::std::os::raw::c_uint = 4139;
pub const CL_DEVICE_VENDOR: ::std::os::raw::c_uint = 4140;
pub const CL_DRIVER_VERSION: ::std::os::raw::c_uint = 4141;
pub const CL_DEVICE_PROFILE: ::std::os::raw::c_uint = 4142;
pub const CL_DEVICE_VERSION: ::std::os::raw::c_uint = 4143;
pub const CL_DEVICE_EXTENSIONS: ::std::os::raw::c_uint = 4144;
pub const CL_DEVICE_PLATFORM: ::std::os::raw::c_uint = 4145;
pub const CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF: ::std::os::raw::c_uint =
    4148;
pub const CL_DEVICE_HOST_UNIFIED_MEMORY: ::std::os::raw::c_uint = 4149;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR: ::std::os::raw::c_uint = 4150;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT: ::std::os::raw::c_uint = 4151;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_INT: ::std::os::raw::c_uint = 4152;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG: ::std::os::raw::c_uint = 4153;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT: ::std::os::raw::c_uint = 4154;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE: ::std::os::raw::c_uint = 4155;
pub const CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF: ::std::os::raw::c_uint = 4156;
pub const CL_DEVICE_OPENCL_C_VERSION: ::std::os::raw::c_uint = 4157;
pub const CL_FP_DENORM: ::std::os::raw::c_uint = 1;
pub const CL_FP_INF_NAN: ::std::os::raw::c_uint = 2;
pub const CL_FP_ROUND_TO_NEAREST: ::std::os::raw::c_uint = 4;
pub const CL_FP_ROUND_TO_ZERO: ::std::os::raw::c_uint = 8;
pub const CL_FP_ROUND_TO_INF: ::std::os::raw::c_uint = 16;
pub const CL_FP_FMA: ::std::os::raw::c_uint = 32;
pub const CL_FP_SOFT_FLOAT: ::std::os::raw::c_uint = 64;
pub const CL_NONE: ::std::os::raw::c_uint = 0;
pub const CL_READ_ONLY_CACHE: ::std::os::raw::c_uint = 1;
pub const CL_READ_WRITE_CACHE: ::std::os::raw::c_uint = 2;
pub const CL_LOCAL: ::std::os::raw::c_uint = 1;
pub const CL_GLOBAL: ::std::os::raw::c_uint = 2;
pub const CL_EXEC_KERNEL: ::std::os::raw::c_uint = 1;
pub const CL_EXEC_NATIVE_KERNEL: ::std::os::raw::c_uint = 2;
pub const CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE: ::std::os::raw::c_uint = 1;
pub const CL_QUEUE_PROFILING_ENABLE: ::std::os::raw::c_uint = 2;
pub const CL_CONTEXT_REFERENCE_COUNT: ::std::os::raw::c_uint = 4224;
pub const CL_CONTEXT_DEVICES: ::std::os::raw::c_uint = 4225;
pub const CL_CONTEXT_PROPERTIES: ::std::os::raw::c_uint = 4226;
pub const CL_CONTEXT_NUM_DEVICES: ::std::os::raw::c_uint = 4227;
pub const CL_CONTEXT_PLATFORM: ::std::os::raw::c_uint = 4228;
pub const CL_QUEUE_CONTEXT: ::std::os::raw::c_uint = 4240;
pub const CL_QUEUE_DEVICE: ::std::os::raw::c_uint = 4241;
pub const CL_QUEUE_REFERENCE_COUNT: ::std::os::raw::c_uint = 4242;
pub const CL_QUEUE_PROPERTIES: ::std::os::raw::c_uint = 4243;
pub const CL_MEM_READ_WRITE: ::std::os::raw::c_uint = 1;
pub const CL_MEM_WRITE_ONLY: ::std::os::raw::c_uint = 2;
pub const CL_MEM_READ_ONLY: ::std::os::raw::c_uint = 4;
pub const CL_MEM_USE_HOST_PTR: ::std::os::raw::c_uint = 8;
pub const CL_MEM_ALLOC_HOST_PTR: ::std::os::raw::c_uint = 16;
pub const CL_MEM_COPY_HOST_PTR: ::std::os::raw::c_uint = 32;
pub const CL_R: ::std::os::raw::c_uint = 4272;
pub const CL_A: ::std::os::raw::c_uint = 4273;
pub const CL_RG: ::std::os::raw::c_uint = 4274;
pub const CL_RA: ::std::os::raw::c_uint = 4275;
pub const CL_RGB: ::std::os::raw::c_uint = 4276;
pub const CL_RGBA: ::std::os::raw::c_uint = 4277;
pub const CL_BGRA: ::std::os::raw::c_uint = 4278;
pub const CL_ARGB: ::std::os::raw::c_uint = 4279;
pub const CL_INTENSITY: ::std::os::raw::c_uint = 4280;
pub const CL_LUMINANCE: ::std::os::raw::c_uint = 4281;
pub const CL_Rx: ::std::os::raw::c_uint = 4282;
pub const CL_RGx: ::std::os::raw::c_uint = 4283;
pub const CL_RGBx: ::std::os::raw::c_uint = 4284;
pub const CL_SNORM_INT8: ::std::os::raw::c_uint = 4304;
pub const CL_SNORM_INT16: ::std::os::raw::c_uint = 4305;
pub const CL_UNORM_INT8: ::std::os::raw::c_uint = 4306;
pub const CL_UNORM_INT16: ::std::os::raw::c_uint = 4307;
pub const CL_UNORM_SHORT_565: ::std::os::raw::c_uint = 4308;
pub const CL_UNORM_SHORT_555: ::std::os::raw::c_uint = 4309;
pub const CL_UNORM_INT_101010: ::std::os::raw::c_uint = 4310;
pub const CL_SIGNED_INT8: ::std::os::raw::c_uint = 4311;
pub const CL_SIGNED_INT16: ::std::os::raw::c_uint = 4312;
pub const CL_SIGNED_INT32: ::std::os::raw::c_uint = 4313;
pub const CL_UNSIGNED_INT8: ::std::os::raw::c_uint = 4314;
pub const CL_UNSIGNED_INT16: ::std::os::raw::c_uint = 4315;
pub const CL_UNSIGNED_INT32: ::std::os::raw::c_uint = 4316;
pub const CL_HALF_FLOAT: ::std::os::raw::c_uint = 4317;
pub const CL_FLOAT: ::std::os::raw::c_uint = 4318;
pub const CL_MEM_OBJECT_BUFFER: ::std::os::raw::c_uint = 4336;
pub const CL_MEM_OBJECT_IMAGE2D: ::std::os::raw::c_uint = 4337;
pub const CL_MEM_OBJECT_IMAGE3D: ::std::os::raw::c_uint = 4338;
pub const CL_MEM_TYPE: ::std::os::raw::c_uint = 4352;
pub const CL_MEM_FLAGS: ::std::os::raw::c_uint = 4353;
pub const CL_MEM_SIZE: ::std::os::raw::c_uint = 4354;
pub const CL_MEM_HOST_PTR: ::std::os::raw::c_uint = 4355;
pub const CL_MEM_MAP_COUNT: ::std::os::raw::c_uint = 4356;
pub const CL_MEM_REFERENCE_COUNT: ::std::os::raw::c_uint = 4357;
pub const CL_MEM_CONTEXT: ::std::os::raw::c_uint = 4358;
pub const CL_MEM_ASSOCIATED_MEMOBJECT: ::std::os::raw::c_uint = 4359;
pub const CL_MEM_OFFSET: ::std::os::raw::c_uint = 4360;
pub const CL_IMAGE_FORMAT: ::std::os::raw::c_uint = 4368;
pub const CL_IMAGE_ELEMENT_SIZE: ::std::os::raw::c_uint = 4369;
pub const CL_IMAGE_ROW_PITCH: ::std::os::raw::c_uint = 4370;
pub const CL_IMAGE_SLICE_PITCH: ::std::os::raw::c_uint = 4371;
pub const CL_IMAGE_WIDTH: ::std::os::raw::c_uint = 4372;
pub const CL_IMAGE_HEIGHT: ::std::os::raw::c_uint = 4373;
pub const CL_IMAGE_DEPTH: ::std::os::raw::c_uint = 4374;
pub const CL_ADDRESS_NONE: ::std::os::raw::c_uint = 4400;
pub const CL_ADDRESS_CLAMP_TO_EDGE: ::std::os::raw::c_uint = 4401;
pub const CL_ADDRESS_CLAMP: ::std::os::raw::c_uint = 4402;
pub const CL_ADDRESS_REPEAT: ::std::os::raw::c_uint = 4403;
pub const CL_ADDRESS_MIRRORED_REPEAT: ::std::os::raw::c_uint = 4404;
pub const CL_FILTER_NEAREST: ::std::os::raw::c_uint = 4416;
pub const CL_FILTER_LINEAR: ::std::os::raw::c_uint = 4417;
pub const CL_SAMPLER_REFERENCE_COUNT: ::std::os::raw::c_uint = 4432;
pub const CL_SAMPLER_CONTEXT: ::std::os::raw::c_uint = 4433;
pub const CL_SAMPLER_NORMALIZED_COORDS: ::std::os::raw::c_uint = 4434;
pub const CL_SAMPLER_ADDRESSING_MODE: ::std::os::raw::c_uint = 4435;
pub const CL_SAMPLER_FILTER_MODE: ::std::os::raw::c_uint = 4436;
pub const CL_MAP_READ: ::std::os::raw::c_uint = 1;
pub const CL_MAP_WRITE: ::std::os::raw::c_uint = 2;
pub const CL_PROGRAM_REFERENCE_COUNT: ::std::os::raw::c_uint = 4448;
pub const CL_PROGRAM_CONTEXT: ::std::os::raw::c_uint = 4449;
pub const CL_PROGRAM_NUM_DEVICES: ::std::os::raw::c_uint = 4450;
pub const CL_PROGRAM_DEVICES: ::std::os::raw::c_uint = 4451;
pub const CL_PROGRAM_SOURCE: ::std::os::raw::c_uint = 4452;
pub const CL_PROGRAM_BINARY_SIZES: ::std::os::raw::c_uint = 4453;
pub const CL_PROGRAM_BINARIES: ::std::os::raw::c_uint = 4454;
pub const CL_PROGRAM_BUILD_STATUS: ::std::os::raw::c_uint = 4481;
pub const CL_PROGRAM_BUILD_OPTIONS: ::std::os::raw::c_uint = 4482;
pub const CL_PROGRAM_BUILD_LOG: ::std::os::raw::c_uint = 4483;
pub const CL_BUILD_SUCCESS: ::std::os::raw::c_uint = 0;
pub const CL_BUILD_NONE: ::std::os::raw::c_int = -1;
pub const CL_BUILD_ERROR: ::std::os::raw::c_int = -2;
pub const CL_BUILD_IN_PROGRESS: ::std::os::raw::c_int = -3;
pub const CL_KERNEL_FUNCTION_NAME: ::std::os::raw::c_uint = 4496;
pub const CL_KERNEL_NUM_ARGS: ::std::os::raw::c_uint = 4497;
pub const CL_KERNEL_REFERENCE_COUNT: ::std::os::raw::c_uint = 4498;
pub const CL_KERNEL_CONTEXT: ::std::os::raw::c_uint = 4499;
pub const CL_KERNEL_PROGRAM: ::std::os::raw::c_uint = 4500;
pub const CL_KERNEL_WORK_GROUP_SIZE: ::std::os::raw::c_uint = 4528;
pub const CL_KERNEL_COMPILE_WORK_GROUP_SIZE: ::std::os::raw::c_uint = 4529;
pub const CL_KERNEL_LOCAL_MEM_SIZE: ::std::os::raw::c_uint = 4530;
pub const CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE: ::std::os::raw::c_uint
          =
    4531;
pub const CL_KERNEL_PRIVATE_MEM_SIZE: ::std::os::raw::c_uint = 4532;
pub const CL_EVENT_COMMAND_QUEUE: ::std::os::raw::c_uint = 4560;
pub const CL_EVENT_COMMAND_TYPE: ::std::os::raw::c_uint = 4561;
pub const CL_EVENT_REFERENCE_COUNT: ::std::os::raw::c_uint = 4562;
pub const CL_EVENT_COMMAND_EXECUTION_STATUS: ::std::os::raw::c_uint = 4563;
pub const CL_EVENT_CONTEXT: ::std::os::raw::c_uint = 4564;
pub const CL_COMMAND_NDRANGE_KERNEL: ::std::os::raw::c_uint = 4592;
pub const CL_COMMAND_TASK: ::std::os::raw::c_uint = 4593;
pub const CL_COMMAND_NATIVE_KERNEL: ::std::os::raw::c_uint = 4594;
pub const CL_COMMAND_READ_BUFFER: ::std::os::raw::c_uint = 4595;
pub const CL_COMMAND_WRITE_BUFFER: ::std::os::raw::c_uint = 4596;
pub const CL_COMMAND_COPY_BUFFER: ::std::os::raw::c_uint = 4597;
pub const CL_COMMAND_READ_IMAGE: ::std::os::raw::c_uint = 4598;
pub const CL_COMMAND_WRITE_IMAGE: ::std::os::raw::c_uint = 4599;
pub const CL_COMMAND_COPY_IMAGE: ::std::os::raw::c_uint = 4600;
pub const CL_COMMAND_COPY_IMAGE_TO_BUFFER: ::std::os::raw::c_uint = 4601;
pub const CL_COMMAND_COPY_BUFFER_TO_IMAGE: ::std::os::raw::c_uint = 4602;
pub const CL_COMMAND_MAP_BUFFER: ::std::os::raw::c_uint = 4603;
pub const CL_COMMAND_MAP_IMAGE: ::std::os::raw::c_uint = 4604;
pub const CL_COMMAND_UNMAP_MEM_OBJECT: ::std::os::raw::c_uint = 4605;
pub const CL_COMMAND_MARKER: ::std::os::raw::c_uint = 4606;
pub const CL_COMMAND_ACQUIRE_GL_OBJECTS: ::std::os::raw::c_uint = 4607;
pub const CL_COMMAND_RELEASE_GL_OBJECTS: ::std::os::raw::c_uint = 4608;
pub const CL_COMMAND_READ_BUFFER_RECT: ::std::os::raw::c_uint = 4609;
pub const CL_COMMAND_WRITE_BUFFER_RECT: ::std::os::raw::c_uint = 4610;
pub const CL_COMMAND_COPY_BUFFER_RECT: ::std::os::raw::c_uint = 4611;
pub const CL_COMMAND_USER: ::std::os::raw::c_uint = 4612;
pub const CL_COMPLETE: ::std::os::raw::c_uint = 0;
pub const CL_RUNNING: ::std::os::raw::c_uint = 1;
pub const CL_SUBMITTED: ::std::os::raw::c_uint = 2;
pub const CL_QUEUED: ::std::os::raw::c_uint = 3;
pub const CL_BUFFER_CREATE_TYPE_REGION: ::std::os::raw::c_uint = 4640;
pub const CL_PROFILING_COMMAND_QUEUED: ::std::os::raw::c_uint = 4736;
pub const CL_PROFILING_COMMAND_SUBMIT: ::std::os::raw::c_uint = 4737;
pub const CL_PROFILING_COMMAND_START: ::std::os::raw::c_uint = 4738;
pub const CL_PROFILING_COMMAND_END: ::std::os::raw::c_uint = 4739;
pub const CLFFT_DUMP_PROGRAMS: ::std::os::raw::c_uint = 1;
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_1>() , 4usize);
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type div_t = _bindgen_ty_1;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_2>() , 4usize);
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
pub type ldiv_t = _bindgen_ty_2;
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(_func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(_nptr: *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_nptr: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _itoa(arg1: ::std::os::raw::c_int,
                 arg2: *mut ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa(arg1: ::std::os::raw::c_long,
                 arg2: *mut ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn atol(_nptr: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(_key: *const ::std::os::raw::c_void,
                   _base: *mut ::std::os::raw::c_void, _nmemb: usize,
                   _size: usize,
                   _compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(_nmemb: usize, _size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(_numer: ::std::os::raw::c_int, _denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn exit(_status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _fullpath(absPath: *mut ::std::os::raw::c_char,
                     relPath: *const ::std::os::raw::c_char, maxLength: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getenv(_string: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(_numer: ::std::os::raw::c_long,
                _denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(_size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lrotl(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl(arg1: ::std::os::raw::c_uint, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn qsort(_base: *mut ::std::os::raw::c_void, _nmemb: usize,
                 _size: usize,
                 _compar:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(_r: *mut ::std::os::raw::c_void, _size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn srand(_seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(_n: *const ::std::os::raw::c_char,
                  _endvoid: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(_n: *const ::std::os::raw::c_char,
                  _endvoid: *mut *mut ::std::os::raw::c_char,
                  _base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(_n: *const ::std::os::raw::c_char,
                   _end: *mut *mut ::std::os::raw::c_char,
                   _base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(_string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(_string: *mut ::std::os::raw::c_char,
                  _value: *mut ::std::os::raw::c_char,
                  _overwrite: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                 arg3: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                 arg3: *mut ::std::os::raw::c_int,
                 arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt(arg1: f64, arg2: ::std::os::raw::c_int,
                 arg3: *mut ::std::os::raw::c_int,
                 arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut ::std::os::raw::c_ushort,
                    arg2: *mut ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(s: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sleep(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_imp___fmode_dll"]
    pub static mut _imp___fmode_dll: *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_environ"]
    pub static mut _environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "_osver"]
    pub static mut _osver: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_imp___osver"]
    pub static mut _imp___osver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_winmajor"]
    pub static mut _winmajor: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_imp___winmajor"]
    pub static mut _imp___winmajor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_winminor"]
    pub static mut _winminor: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_imp___winminor"]
    pub static mut _imp___winminor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_winver"]
    pub static mut _winver: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_imp___winver"]
    pub static mut _imp___winver: *mut ::std::os::raw::c_uint;
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_char; 16usize];
pub type __cl_float4 = __m128;
pub type __cl_uchar16 = __m128i;
pub type __cl_char16 = __m128i;
pub type __cl_ushort8 = __m128i;
pub type __cl_short8 = __m128i;
pub type __cl_uint4 = __m128i;
pub type __cl_int4 = __m128i;
pub type __cl_ulong2 = __m128i;
pub type __cl_long2 = __m128i;
pub type __cl_double2 = __m128d;
pub type __cl_uchar8 = __m64;
pub type __cl_char8 = __m64;
pub type __cl_ushort4 = __m64;
pub type __cl_short4 = __m64;
pub type __cl_uint2 = __m64;
pub type __cl_int2 = __m64;
pub type __cl_ulong1 = __m64;
pub type __cl_long1 = __m64;
pub type __cl_float2 = __m64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub s: __BindgenUnionField<[cl_char; 2usize]>,
    pub bindgen_union_field: [u8; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_3>() , 2usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_3>() , 1usize);
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_4 {
    pub s: __BindgenUnionField<[cl_char; 4usize]>,
    pub bindgen_union_field: [u8; 4usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_4>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_4>() , 1usize);
}
impl Clone for _bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_5 {
    pub s: __BindgenUnionField<[cl_char; 8usize]>,
    pub v8: __BindgenUnionField<__cl_char8>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_5>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_5>() , 8usize);
}
impl Clone for _bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_6 {
    pub s: __BindgenUnionField<[cl_char; 16usize]>,
    pub v8: __BindgenUnionField<[__cl_char8; 2usize]>,
    pub v16: __BindgenUnionField<__cl_char16>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_6>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_6>() , 16usize);
}
impl Clone for _bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7 {
    pub s: __BindgenUnionField<[cl_uchar; 2usize]>,
    pub bindgen_union_field: [u8; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7>() , 2usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7>() , 1usize);
}
impl Clone for _bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_8 {
    pub s: __BindgenUnionField<[cl_uchar; 4usize]>,
    pub bindgen_union_field: [u8; 4usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_8>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_8>() , 1usize);
}
impl Clone for _bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_9 {
    pub s: __BindgenUnionField<[cl_uchar; 8usize]>,
    pub v8: __BindgenUnionField<__cl_uchar8>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_9>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_9>() , 8usize);
}
impl Clone for _bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_10 {
    pub s: __BindgenUnionField<[cl_uchar; 16usize]>,
    pub v8: __BindgenUnionField<[__cl_uchar8; 2usize]>,
    pub v16: __BindgenUnionField<__cl_uchar16>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_10>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_10>() , 16usize);
}
impl Clone for _bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_11 {
    pub s: __BindgenUnionField<[cl_short; 2usize]>,
    pub bindgen_union_field: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11>() , 2usize);
}
impl Clone for _bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_12 {
    pub s: __BindgenUnionField<[cl_short; 4usize]>,
    pub v4: __BindgenUnionField<__cl_short4>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12>() , 8usize);
}
impl Clone for _bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_13 {
    pub s: __BindgenUnionField<[cl_short; 8usize]>,
    pub v4: __BindgenUnionField<[__cl_short4; 2usize]>,
    pub v8: __BindgenUnionField<__cl_short8>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_13>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_13>() , 16usize);
}
impl Clone for _bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_14 {
    pub s: __BindgenUnionField<[cl_short; 16usize]>,
    pub v4: __BindgenUnionField<[__cl_short4; 4usize]>,
    pub v8: __BindgenUnionField<[__cl_short8; 2usize]>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_14>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_14>() , 16usize);
}
impl Clone for _bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_15 {
    pub s: __BindgenUnionField<[cl_ushort; 2usize]>,
    pub bindgen_union_field: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_15>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_15>() , 2usize);
}
impl Clone for _bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_16 {
    pub s: __BindgenUnionField<[cl_ushort; 4usize]>,
    pub v4: __BindgenUnionField<__cl_ushort4>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16>() , 8usize);
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_17 {
    pub s: __BindgenUnionField<[cl_ushort; 8usize]>,
    pub v4: __BindgenUnionField<[__cl_ushort4; 2usize]>,
    pub v8: __BindgenUnionField<__cl_ushort8>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_17>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_17>() , 16usize);
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_18 {
    pub s: __BindgenUnionField<[cl_ushort; 16usize]>,
    pub v4: __BindgenUnionField<[__cl_ushort4; 4usize]>,
    pub v8: __BindgenUnionField<[__cl_ushort8; 2usize]>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_18>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_18>() , 16usize);
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_19 {
    pub s: __BindgenUnionField<[cl_int; 2usize]>,
    pub v2: __BindgenUnionField<__cl_int2>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_19() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_19>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_19>() , 8usize);
}
impl Clone for _bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_20 {
    pub s: __BindgenUnionField<[cl_int; 4usize]>,
    pub v2: __BindgenUnionField<[__cl_int2; 2usize]>,
    pub v4: __BindgenUnionField<__cl_int4>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_20() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_20>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_20>() , 16usize);
}
impl Clone for _bindgen_ty_20 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_21 {
    pub s: __BindgenUnionField<[cl_int; 8usize]>,
    pub v2: __BindgenUnionField<[__cl_int2; 4usize]>,
    pub v4: __BindgenUnionField<[__cl_int4; 2usize]>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_21() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_21>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_21>() , 16usize);
}
impl Clone for _bindgen_ty_21 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_22 {
    pub s: __BindgenUnionField<[cl_int; 16usize]>,
    pub v2: __BindgenUnionField<[__cl_int2; 8usize]>,
    pub v4: __BindgenUnionField<[__cl_int4; 4usize]>,
    pub bindgen_union_field: [u8; 64usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_22() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_22>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_22>() , 16usize);
}
impl Clone for _bindgen_ty_22 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_23 {
    pub s: __BindgenUnionField<[cl_uint; 2usize]>,
    pub v2: __BindgenUnionField<__cl_uint2>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_23() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_23>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_23>() , 8usize);
}
impl Clone for _bindgen_ty_23 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_24 {
    pub s: __BindgenUnionField<[cl_uint; 4usize]>,
    pub v2: __BindgenUnionField<[__cl_uint2; 2usize]>,
    pub v4: __BindgenUnionField<__cl_uint4>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_24() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_24>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_24>() , 16usize);
}
impl Clone for _bindgen_ty_24 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_25 {
    pub s: __BindgenUnionField<[cl_uint; 8usize]>,
    pub v2: __BindgenUnionField<[__cl_uint2; 4usize]>,
    pub v4: __BindgenUnionField<[__cl_uint4; 2usize]>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_25() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_25>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_25>() , 16usize);
}
impl Clone for _bindgen_ty_25 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_26 {
    pub s: __BindgenUnionField<[cl_uint; 16usize]>,
    pub v2: __BindgenUnionField<[__cl_uint2; 8usize]>,
    pub v4: __BindgenUnionField<[__cl_uint4; 4usize]>,
    pub bindgen_union_field: [u8; 64usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_26() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_26>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_26>() , 16usize);
}
impl Clone for _bindgen_ty_26 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_27 {
    pub s: __BindgenUnionField<[cl_long; 2usize]>,
    pub v2: __BindgenUnionField<__cl_long2>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_27() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_27>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_27>() , 16usize);
}
impl Clone for _bindgen_ty_27 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_28 {
    pub s: __BindgenUnionField<[cl_long; 4usize]>,
    pub v2: __BindgenUnionField<[__cl_long2; 2usize]>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_28() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_28>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_28>() , 16usize);
}
impl Clone for _bindgen_ty_28 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_29 {
    pub s: __BindgenUnionField<[cl_long; 8usize]>,
    pub v2: __BindgenUnionField<[__cl_long2; 4usize]>,
    pub bindgen_union_field: [u8; 64usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_29() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_29>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_29>() , 16usize);
}
impl Clone for _bindgen_ty_29 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_30 {
    pub s: __BindgenUnionField<[cl_long; 16usize]>,
    pub v2: __BindgenUnionField<[__cl_long2; 8usize]>,
    pub bindgen_union_field: [u8; 128usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_30() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_30>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_30>() , 16usize);
}
impl Clone for _bindgen_ty_30 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_31 {
    pub s: __BindgenUnionField<[cl_ulong; 2usize]>,
    pub v2: __BindgenUnionField<__cl_ulong2>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_31() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_31>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_31>() , 16usize);
}
impl Clone for _bindgen_ty_31 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_32 {
    pub s: __BindgenUnionField<[cl_ulong; 4usize]>,
    pub v2: __BindgenUnionField<[__cl_ulong2; 2usize]>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_32() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_32>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_32>() , 16usize);
}
impl Clone for _bindgen_ty_32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_33 {
    pub s: __BindgenUnionField<[cl_ulong; 8usize]>,
    pub v2: __BindgenUnionField<[__cl_ulong2; 4usize]>,
    pub bindgen_union_field: [u8; 64usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_33() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_33>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_33>() , 16usize);
}
impl Clone for _bindgen_ty_33 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_34 {
    pub s: __BindgenUnionField<[cl_ulong; 16usize]>,
    pub v2: __BindgenUnionField<[__cl_ulong2; 8usize]>,
    pub bindgen_union_field: [u8; 128usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_34() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_34>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_34>() , 16usize);
}
impl Clone for _bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_35 {
    pub s: __BindgenUnionField<[cl_float; 2usize]>,
    pub v2: __BindgenUnionField<__cl_float2>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_35() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_35>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_35>() , 8usize);
}
impl Clone for _bindgen_ty_35 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_36 {
    pub s: __BindgenUnionField<[cl_float; 4usize]>,
    pub v2: __BindgenUnionField<[__cl_float2; 2usize]>,
    pub v4: __BindgenUnionField<__cl_float4>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_36() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_36>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_36>() , 16usize);
}
impl Clone for _bindgen_ty_36 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_37 {
    pub s: __BindgenUnionField<[cl_float; 8usize]>,
    pub v2: __BindgenUnionField<[__cl_float2; 4usize]>,
    pub v4: __BindgenUnionField<[__cl_float4; 2usize]>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_37() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_37>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_37>() , 16usize);
}
impl Clone for _bindgen_ty_37 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_38 {
    pub s: __BindgenUnionField<[cl_float; 16usize]>,
    pub v2: __BindgenUnionField<[__cl_float2; 8usize]>,
    pub v4: __BindgenUnionField<[__cl_float4; 4usize]>,
    pub bindgen_union_field: [u8; 64usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_38() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_38>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_38>() , 16usize);
}
impl Clone for _bindgen_ty_38 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_39 {
    pub s: __BindgenUnionField<[cl_double; 2usize]>,
    pub v2: __BindgenUnionField<__cl_double2>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_39() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_39>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_39>() , 16usize);
}
impl Clone for _bindgen_ty_39 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_40 {
    pub s: __BindgenUnionField<[cl_double; 4usize]>,
    pub v2: __BindgenUnionField<[__cl_double2; 2usize]>,
    pub bindgen_union_field: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_40() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_40>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_40>() , 16usize);
}
impl Clone for _bindgen_ty_40 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_41 {
    pub s: __BindgenUnionField<[cl_double; 8usize]>,
    pub v2: __BindgenUnionField<[__cl_double2; 4usize]>,
    pub bindgen_union_field: [u8; 64usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_41() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_41>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_41>() , 16usize);
}
impl Clone for _bindgen_ty_41 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_42 {
    pub s: __BindgenUnionField<[cl_double; 16usize]>,
    pub v2: __BindgenUnionField<[__cl_double2; 8usize]>,
    pub bindgen_union_field: [u8; 128usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_42() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_42>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_42>() , 16usize);
}
impl Clone for _bindgen_ty_42 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_platform_id([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_device_id([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_context([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_command_queue([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_mem([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_program([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_kernel([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_event([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cl_sampler([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cl_image_format {
    pub image_channel_order: cl_channel_order,
    pub image_channel_data_type: cl_channel_type,
}
#[test]
fn bindgen_test_layout__cl_image_format() {
    assert_eq!(::std::mem::size_of::<_cl_image_format>() , 8usize);
    assert_eq!(::std::mem::align_of::<_cl_image_format>() , 4usize);
}
impl Clone for _cl_image_format {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cl_buffer_region {
    pub origin: usize,
    pub size: usize,
}
#[test]
fn bindgen_test_layout__cl_buffer_region() {
    assert_eq!(::std::mem::size_of::<_cl_buffer_region>() , 16usize);
    assert_eq!(::std::mem::align_of::<_cl_buffer_region>() , 8usize);
}
impl Clone for _cl_buffer_region {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /********************************************************************************************************/
    pub fn clGetPlatformIDs(arg1: cl_uint, arg2: *mut cl_platform_id,
                            arg3: *mut cl_uint) -> cl_int;
}
extern "C" {
    pub fn clGetPlatformInfo(arg1: cl_platform_id, arg2: cl_platform_info,
                             arg3: usize, arg4: *mut ::std::os::raw::c_void,
                             arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clGetDeviceIDs(arg1: cl_platform_id, arg2: cl_device_type,
                          arg3: cl_uint, arg4: *mut cl_device_id,
                          arg5: *mut cl_uint) -> cl_int;
}
extern "C" {
    pub fn clGetDeviceInfo(arg1: cl_device_id, arg2: cl_device_info,
                           arg3: usize, arg4: *mut ::std::os::raw::c_void,
                           arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clCreateContext(arg1: *const cl_context_properties, arg2: cl_uint,
                           arg3: *const cl_device_id,
                           arg4:
                               ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              *const ::std::os::raw::c_char,
                                                                          arg2:
                                                                              *const ::std::os::raw::c_void,
                                                                          arg3:
                                                                              usize,
                                                                          arg4:
                                                                              *mut ::std::os::raw::c_void)>,
                           arg5: *mut ::std::os::raw::c_void,
                           arg6: *mut cl_int) -> cl_context;
}
extern "C" {
    pub fn clCreateContextFromType(arg1: *const cl_context_properties,
                                   arg2: cl_device_type,
                                   arg3:
                                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                      *const ::std::os::raw::c_char,
                                                                                  arg2:
                                                                                      *const ::std::os::raw::c_void,
                                                                                  arg3:
                                                                                      usize,
                                                                                  arg4:
                                                                                      *mut ::std::os::raw::c_void)>,
                                   arg4: *mut ::std::os::raw::c_void,
                                   arg5: *mut cl_int) -> cl_context;
}
extern "C" {
    pub fn clRetainContext(arg1: cl_context) -> cl_int;
}
extern "C" {
    pub fn clReleaseContext(arg1: cl_context) -> cl_int;
}
extern "C" {
    pub fn clGetContextInfo(arg1: cl_context, arg2: cl_context_info,
                            arg3: usize, arg4: *mut ::std::os::raw::c_void,
                            arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clCreateCommandQueue(arg1: cl_context, arg2: cl_device_id,
                                arg3: cl_command_queue_properties,
                                arg4: *mut cl_int) -> cl_command_queue;
}
extern "C" {
    pub fn clRetainCommandQueue(arg1: cl_command_queue) -> cl_int;
}
extern "C" {
    pub fn clReleaseCommandQueue(arg1: cl_command_queue) -> cl_int;
}
extern "C" {
    pub fn clGetCommandQueueInfo(arg1: cl_command_queue,
                                 arg2: cl_command_queue_info, arg3: usize,
                                 arg4: *mut ::std::os::raw::c_void,
                                 arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clCreateBuffer(arg1: cl_context, arg2: cl_mem_flags, arg3: usize,
                          arg4: *mut ::std::os::raw::c_void,
                          arg5: *mut cl_int) -> cl_mem;
}
extern "C" {
    pub fn clCreateSubBuffer(arg1: cl_mem, arg2: cl_mem_flags,
                             arg3: cl_buffer_create_type,
                             arg4: *const ::std::os::raw::c_void,
                             arg5: *mut cl_int) -> cl_mem;
}
extern "C" {
    pub fn clCreateImage2D(arg1: cl_context, arg2: cl_mem_flags,
                           arg3: *const cl_image_format, arg4: usize,
                           arg5: usize, arg6: usize,
                           arg7: *mut ::std::os::raw::c_void,
                           arg8: *mut cl_int) -> cl_mem;
}
extern "C" {
    pub fn clCreateImage3D(arg1: cl_context, arg2: cl_mem_flags,
                           arg3: *const cl_image_format, arg4: usize,
                           arg5: usize, arg6: usize, arg7: usize, arg8: usize,
                           arg9: *mut ::std::os::raw::c_void,
                           arg10: *mut cl_int) -> cl_mem;
}
extern "C" {
    pub fn clRetainMemObject(arg1: cl_mem) -> cl_int;
}
extern "C" {
    pub fn clReleaseMemObject(arg1: cl_mem) -> cl_int;
}
extern "C" {
    pub fn clGetSupportedImageFormats(arg1: cl_context, arg2: cl_mem_flags,
                                      arg3: cl_mem_object_type, arg4: cl_uint,
                                      arg5: *mut cl_image_format,
                                      arg6: *mut cl_uint) -> cl_int;
}
extern "C" {
    pub fn clGetMemObjectInfo(arg1: cl_mem, arg2: cl_mem_info, arg3: usize,
                              arg4: *mut ::std::os::raw::c_void,
                              arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clGetImageInfo(arg1: cl_mem, arg2: cl_image_info, arg3: usize,
                          arg4: *mut ::std::os::raw::c_void, arg5: *mut usize)
     -> cl_int;
}
extern "C" {
    pub fn clSetMemObjectDestructorCallback(arg1: cl_mem,
                                            arg2:
                                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                               cl_mem,
                                                                                           arg2:
                                                                                               *mut ::std::os::raw::c_void)>,
                                            arg3: *mut ::std::os::raw::c_void)
     -> cl_int;
}
extern "C" {
    pub fn clCreateSampler(arg1: cl_context, arg2: cl_bool,
                           arg3: cl_addressing_mode, arg4: cl_filter_mode,
                           arg5: *mut cl_int) -> cl_sampler;
}
extern "C" {
    pub fn clRetainSampler(arg1: cl_sampler) -> cl_int;
}
extern "C" {
    pub fn clReleaseSampler(arg1: cl_sampler) -> cl_int;
}
extern "C" {
    pub fn clGetSamplerInfo(arg1: cl_sampler, arg2: cl_sampler_info,
                            arg3: usize, arg4: *mut ::std::os::raw::c_void,
                            arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clCreateProgramWithSource(arg1: cl_context, arg2: cl_uint,
                                     arg3: *mut *const ::std::os::raw::c_char,
                                     arg4: *const usize, arg5: *mut cl_int)
     -> cl_program;
}
extern "C" {
    pub fn clCreateProgramWithBinary(arg1: cl_context, arg2: cl_uint,
                                     arg3: *const cl_device_id,
                                     arg4: *const usize,
                                     arg5:
                                         *mut *const ::std::os::raw::c_uchar,
                                     arg6: *mut cl_int, arg7: *mut cl_int)
     -> cl_program;
}
extern "C" {
    pub fn clRetainProgram(arg1: cl_program) -> cl_int;
}
extern "C" {
    pub fn clReleaseProgram(arg1: cl_program) -> cl_int;
}
extern "C" {
    pub fn clBuildProgram(arg1: cl_program, arg2: cl_uint,
                          arg3: *const cl_device_id,
                          arg4: *const ::std::os::raw::c_char,
                          arg5:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             cl_program,
                                                                         arg2:
                                                                             *mut ::std::os::raw::c_void)>,
                          arg6: *mut ::std::os::raw::c_void) -> cl_int;
}
extern "C" {
    pub fn clUnloadCompiler() -> cl_int;
}
extern "C" {
    pub fn clGetProgramInfo(arg1: cl_program, arg2: cl_program_info,
                            arg3: usize, arg4: *mut ::std::os::raw::c_void,
                            arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clGetProgramBuildInfo(arg1: cl_program, arg2: cl_device_id,
                                 arg3: cl_program_build_info, arg4: usize,
                                 arg5: *mut ::std::os::raw::c_void,
                                 arg6: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clCreateKernel(arg1: cl_program,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *mut cl_int) -> cl_kernel;
}
extern "C" {
    pub fn clCreateKernelsInProgram(arg1: cl_program, arg2: cl_uint,
                                    arg3: *mut cl_kernel, arg4: *mut cl_uint)
     -> cl_int;
}
extern "C" {
    pub fn clRetainKernel(arg1: cl_kernel) -> cl_int;
}
extern "C" {
    pub fn clReleaseKernel(arg1: cl_kernel) -> cl_int;
}
extern "C" {
    pub fn clSetKernelArg(arg1: cl_kernel, arg2: cl_uint, arg3: usize,
                          arg4: *const ::std::os::raw::c_void) -> cl_int;
}
extern "C" {
    pub fn clGetKernelInfo(arg1: cl_kernel, arg2: cl_kernel_info, arg3: usize,
                           arg4: *mut ::std::os::raw::c_void,
                           arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clGetKernelWorkGroupInfo(arg1: cl_kernel, arg2: cl_device_id,
                                    arg3: cl_kernel_work_group_info,
                                    arg4: usize,
                                    arg5: *mut ::std::os::raw::c_void,
                                    arg6: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clWaitForEvents(arg1: cl_uint, arg2: *const cl_event) -> cl_int;
}
extern "C" {
    pub fn clGetEventInfo(arg1: cl_event, arg2: cl_event_info, arg3: usize,
                          arg4: *mut ::std::os::raw::c_void, arg5: *mut usize)
     -> cl_int;
}
extern "C" {
    pub fn clCreateUserEvent(arg1: cl_context, arg2: *mut cl_int) -> cl_event;
}
extern "C" {
    pub fn clRetainEvent(arg1: cl_event) -> cl_int;
}
extern "C" {
    pub fn clReleaseEvent(arg1: cl_event) -> cl_int;
}
extern "C" {
    pub fn clSetUserEventStatus(arg1: cl_event, arg2: cl_int) -> cl_int;
}
extern "C" {
    pub fn clSetEventCallback(arg1: cl_event, arg2: cl_int,
                              arg3:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 cl_event,
                                                                             arg2:
                                                                                 cl_int,
                                                                             arg3:
                                                                                 *mut ::std::os::raw::c_void)>,
                              arg4: *mut ::std::os::raw::c_void) -> cl_int;
}
extern "C" {
    pub fn clGetEventProfilingInfo(arg1: cl_event, arg2: cl_profiling_info,
                                   arg3: usize,
                                   arg4: *mut ::std::os::raw::c_void,
                                   arg5: *mut usize) -> cl_int;
}
extern "C" {
    pub fn clFlush(arg1: cl_command_queue) -> cl_int;
}
extern "C" {
    pub fn clFinish(arg1: cl_command_queue) -> cl_int;
}
extern "C" {
    pub fn clEnqueueReadBuffer(arg1: cl_command_queue, arg2: cl_mem,
                               arg3: cl_bool, arg4: usize, arg5: usize,
                               arg6: *mut ::std::os::raw::c_void,
                               arg7: cl_uint, arg8: *const cl_event,
                               arg9: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueReadBufferRect(arg1: cl_command_queue, arg2: cl_mem,
                                   arg3: cl_bool, arg4: *const usize,
                                   arg5: *const usize, arg6: *const usize,
                                   arg7: usize, arg8: usize, arg9: usize,
                                   arg10: usize,
                                   arg11: *mut ::std::os::raw::c_void,
                                   arg12: cl_uint, arg13: *const cl_event,
                                   arg14: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueWriteBuffer(arg1: cl_command_queue, arg2: cl_mem,
                                arg3: cl_bool, arg4: usize, arg5: usize,
                                arg6: *const ::std::os::raw::c_void,
                                arg7: cl_uint, arg8: *const cl_event,
                                arg9: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueWriteBufferRect(arg1: cl_command_queue, arg2: cl_mem,
                                    arg3: cl_bool, arg4: *const usize,
                                    arg5: *const usize, arg6: *const usize,
                                    arg7: usize, arg8: usize, arg9: usize,
                                    arg10: usize,
                                    arg11: *const ::std::os::raw::c_void,
                                    arg12: cl_uint, arg13: *const cl_event,
                                    arg14: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueCopyBuffer(arg1: cl_command_queue, arg2: cl_mem,
                               arg3: cl_mem, arg4: usize, arg5: usize,
                               arg6: usize, arg7: cl_uint,
                               arg8: *const cl_event, arg9: *mut cl_event)
     -> cl_int;
}
extern "C" {
    pub fn clEnqueueCopyBufferRect(arg1: cl_command_queue, arg2: cl_mem,
                                   arg3: cl_mem, arg4: *const usize,
                                   arg5: *const usize, arg6: *const usize,
                                   arg7: usize, arg8: usize, arg9: usize,
                                   arg10: usize, arg11: cl_uint,
                                   arg12: *const cl_event,
                                   arg13: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueReadImage(arg1: cl_command_queue, arg2: cl_mem,
                              arg3: cl_bool, arg4: *const usize,
                              arg5: *const usize, arg6: usize, arg7: usize,
                              arg8: *mut ::std::os::raw::c_void,
                              arg9: cl_uint, arg10: *const cl_event,
                              arg11: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueWriteImage(arg1: cl_command_queue, arg2: cl_mem,
                               arg3: cl_bool, arg4: *const usize,
                               arg5: *const usize, arg6: usize, arg7: usize,
                               arg8: *const ::std::os::raw::c_void,
                               arg9: cl_uint, arg10: *const cl_event,
                               arg11: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueCopyImage(arg1: cl_command_queue, arg2: cl_mem,
                              arg3: cl_mem, arg4: *const usize,
                              arg5: *const usize, arg6: *const usize,
                              arg7: cl_uint, arg8: *const cl_event,
                              arg9: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueCopyImageToBuffer(arg1: cl_command_queue, arg2: cl_mem,
                                      arg3: cl_mem, arg4: *const usize,
                                      arg5: *const usize, arg6: usize,
                                      arg7: cl_uint, arg8: *const cl_event,
                                      arg9: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueCopyBufferToImage(arg1: cl_command_queue, arg2: cl_mem,
                                      arg3: cl_mem, arg4: usize,
                                      arg5: *const usize, arg6: *const usize,
                                      arg7: cl_uint, arg8: *const cl_event,
                                      arg9: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueMapBuffer(arg1: cl_command_queue, arg2: cl_mem,
                              arg3: cl_bool, arg4: cl_map_flags, arg5: usize,
                              arg6: usize, arg7: cl_uint,
                              arg8: *const cl_event, arg9: *mut cl_event,
                              arg10: *mut cl_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn clEnqueueMapImage(arg1: cl_command_queue, arg2: cl_mem,
                             arg3: cl_bool, arg4: cl_map_flags,
                             arg5: *const usize, arg6: *const usize,
                             arg7: *mut usize, arg8: *mut usize,
                             arg9: cl_uint, arg10: *const cl_event,
                             arg11: *mut cl_event, arg12: *mut cl_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn clEnqueueUnmapMemObject(arg1: cl_command_queue, arg2: cl_mem,
                                   arg3: *mut ::std::os::raw::c_void,
                                   arg4: cl_uint, arg5: *const cl_event,
                                   arg6: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueNDRangeKernel(arg1: cl_command_queue, arg2: cl_kernel,
                                  arg3: cl_uint, arg4: *const usize,
                                  arg5: *const usize, arg6: *const usize,
                                  arg7: cl_uint, arg8: *const cl_event,
                                  arg9: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueTask(arg1: cl_command_queue, arg2: cl_kernel,
                         arg3: cl_uint, arg4: *const cl_event,
                         arg5: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueNativeKernel(arg1: cl_command_queue,
                                 user_func:
                                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut ::std::os::raw::c_void)>,
                                 arg2: *mut ::std::os::raw::c_void,
                                 arg3: usize, arg4: cl_uint,
                                 arg5: *const cl_mem,
                                 arg6: *mut *const ::std::os::raw::c_void,
                                 arg7: cl_uint, arg8: *const cl_event,
                                 arg9: *mut cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueMarker(arg1: cl_command_queue, arg2: *mut cl_event)
     -> cl_int;
}
extern "C" {
    pub fn clEnqueueWaitForEvents(arg1: cl_command_queue, arg2: cl_uint,
                                  arg3: *const cl_event) -> cl_int;
}
extern "C" {
    pub fn clEnqueueBarrier(arg1: cl_command_queue) -> cl_int;
}
extern "C" {
    pub fn clGetExtensionFunctionAddress(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
#[repr(i32)]
/*   @brief clfft error codes definition(incorporating OpenCL error definitions)
 *
 *   This enumeration is a superset of the OpenCL error codes.  For example, CL_OUT_OF_HOST_MEMORY,
 *   which is defined in cl.h is aliased as CLFFT_OUT_OF_HOST_MEMORY.  The set of basic OpenCL
 *   error codes is extended to add extra values specific to the clfft package.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clfftStatus_ {
    CLFFT_INVALID_GLOBAL_WORK_SIZE = -63,
    CLFFT_INVALID_MIP_LEVEL = -62,
    CLFFT_INVALID_BUFFER_SIZE = -61,
    CLFFT_INVALID_GL_OBJECT = -60,
    CLFFT_INVALID_OPERATION = -59,
    CLFFT_INVALID_EVENT = -58,
    CLFFT_INVALID_EVENT_WAIT_LIST = -57,
    CLFFT_INVALID_GLOBAL_OFFSET = -56,
    CLFFT_INVALID_WORK_ITEM_SIZE = -55,
    CLFFT_INVALID_WORK_GROUP_SIZE = -54,
    CLFFT_INVALID_WORK_DIMENSION = -53,
    CLFFT_INVALID_KERNEL_ARGS = -52,
    CLFFT_INVALID_ARG_SIZE = -51,
    CLFFT_INVALID_ARG_VALUE = -50,
    CLFFT_INVALID_ARG_INDEX = -49,
    CLFFT_INVALID_KERNEL = -48,
    CLFFT_INVALID_KERNEL_DEFINITION = -47,
    CLFFT_INVALID_KERNEL_NAME = -46,
    CLFFT_INVALID_PROGRAM_EXECUTABLE = -45,
    CLFFT_INVALID_PROGRAM = -44,
    CLFFT_INVALID_BUILD_OPTIONS = -43,
    CLFFT_INVALID_BINARY = -42,
    CLFFT_INVALID_SAMPLER = -41,
    CLFFT_INVALID_IMAGE_SIZE = -40,
    CLFFT_INVALID_IMAGE_FORMAT_DESCRIPTOR = -39,
    CLFFT_INVALID_MEM_OBJECT = -38,
    CLFFT_INVALID_HOST_PTR = -37,
    CLFFT_INVALID_COMMAND_QUEUE = -36,
    CLFFT_INVALID_QUEUE_PROPERTIES = -35,
    CLFFT_INVALID_CONTEXT = -34,
    CLFFT_INVALID_DEVICE = -33,
    CLFFT_INVALID_PLATFORM = -32,
    CLFFT_INVALID_DEVICE_TYPE = -31,
    CLFFT_INVALID_VALUE = -30,
    CLFFT_MAP_FAILURE = -12,
    CLFFT_BUILD_PROGRAM_FAILURE = -11,
    CLFFT_IMAGE_FORMAT_NOT_SUPPORTED = -10,
    CLFFT_IMAGE_FORMAT_MISMATCH = -9,
    CLFFT_MEM_COPY_OVERLAP = -8,
    CLFFT_PROFILING_INFO_NOT_AVAILABLE = -7,
    CLFFT_OUT_OF_HOST_MEMORY = -6,
    CLFFT_OUT_OF_RESOURCES = -5,
    CLFFT_MEM_OBJECT_ALLOCATION_FAILURE = -4,
    CLFFT_COMPILER_NOT_AVAILABLE = -3,
    CLFFT_DEVICE_NOT_AVAILABLE = -2,
    CLFFT_DEVICE_NOT_FOUND = -1,
    CLFFT_SUCCESS = 0,
    CLFFT_BUGCHECK = 4096,
    CLFFT_NOTIMPLEMENTED = 4097,
    CLFFT_TRANSPOSED_NOTIMPLEMENTED = 4098,
    CLFFT_FILE_NOT_FOUND = 4099,
    CLFFT_FILE_CREATE_FAILURE = 4100,
    CLFFT_VERSION_MISMATCH = 4101,
    CLFFT_INVALID_PLAN = 4102,
    CLFFT_DEVICE_NO_DOUBLE = 4103,
    CLFFT_DEVICE_MISMATCH = 4104,
    CLFFT_ENDSTATUS = 4105,
}
pub use self::clfftStatus_ as clfftStatus;
#[repr(i32)]
/*   @brief The dimension of the input and output buffers that is fed into all FFT transforms */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clfftDim_ {
    CLFFT_1D = 1,
    CLFFT_2D = 2,
    CLFFT_3D = 3,
    ENDDIMENSION = 4,
}
pub use self::clfftDim_ as clfftDim;
#[repr(i32)]
/*   @brief Specify the expected layouts of the buffers */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clfftLayout_ {
    CLFFT_COMPLEX_INTERLEAVED = 1,
    CLFFT_COMPLEX_PLANAR = 2,
    CLFFT_HERMITIAN_INTERLEAVED = 3,
    CLFFT_HERMITIAN_PLANAR = 4,
    CLFFT_REAL = 5,
    ENDLAYOUT = 6,
}
pub use self::clfftLayout_ as clfftLayout;
#[repr(i32)]
/*   @brief Specify the expected precision of each FFT.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clfftPrecision_ {
    CLFFT_SINGLE = 1,
    CLFFT_DOUBLE = 2,
    CLFFT_SINGLE_FAST = 3,
    CLFFT_DOUBLE_FAST = 4,
    ENDPRECISION = 5,
}
pub use self::clfftPrecision_ as clfftPrecision;
pub const clfftDirection__CLFFT_MINUS: clfftDirection_ =
    clfftDirection_::CLFFT_FORWARD;
pub const clfftDirection__CLFFT_PLUS: clfftDirection_ =
    clfftDirection_::CLFFT_BACKWARD;
#[repr(i32)]
/*   @brief Specify the expected direction of each FFT, time or the frequency domains */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clfftDirection_ {
    CLFFT_FORWARD = -1,
    CLFFT_BACKWARD = 1,
    ENDDIRECTION = 2,
}
pub use self::clfftDirection_ as clfftDirection;
#[repr(i32)]
/*   @brief Specify wheter the input buffers are overwritten with results */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clfftResultLocation_ {
    CLFFT_INPLACE = 1,
    CLFFT_OUTOFPLACE = 2,
    ENDPLACE = 3,
}
pub use self::clfftResultLocation_ as clfftResultLocation;
#[repr(i32)]
/*  @brief Determines whether the result is returned in original order. It is valid only for
dimensions greater than 1. */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clfftResultTransposed_ {
    CLFFT_NOTRANSPOSE = 1,
    CLFFT_TRANSPOSED = 2,
    ENDTRANSPOSED = 3,
}
pub use self::clfftResultTransposed_ as clfftResultTransposed;
/*  @brief Data structure that can be passed to clfftSetup() to control the behavior of the FFT runtime
 *  @details This structure contains values that can be initialized before instantiation of the FFT runtime
 *  with ::clfftSetup().  To initialize this structure, pass a pointer to a user struct to ::clfftInitSetupData( ),
 *  which clears the structure and sets the version member variables to the current values.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clfftSetupData_ {
    /* < Major version number of the project; signifies possible major API changes. */
    pub major: cl_uint,
    /* < Minor version number of the project; minor API changes that can break backward compatibility. */
    pub minor: cl_uint,
    /* < Patch version number of the project; always incrementing number, signifies change over time. */
    pub patch: cl_uint,
    /*  	Bitwise flags that control the behavior of library debug logic. */
    pub debugFlags: cl_ulong,
}
#[test]
fn bindgen_test_layout_clfftSetupData_() {
    assert_eq!(::std::mem::size_of::<clfftSetupData_>() , 24usize);
    assert_eq!(::std::mem::align_of::<clfftSetupData_>() , 8usize);
}
impl Clone for clfftSetupData_ {
    fn clone(&self) -> Self { *self }
}
pub type clfftSetupData = clfftSetupData_;
#[repr(i32)]
/*  @brief Type of Callback function.
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clfftCallbackType_ { PRECALLBACK = 0, POSTCALLBACK = 1, }
pub use self::clfftCallbackType_ as clfftCallbackType;
/*   @brief An abstract handle to the object that represents the state of the FFT(s) */
pub type clfftPlanHandle = usize;
extern "C" {
    /*  @brief Initialize the internal FFT resources.
	 *  @details The internal resources include FFT implementation caches kernels, programs, and buffers.
	 *  @param[in] setupData Data structure that is passed into the setup routine to control FFT generation behavior
	 * 	and debug functionality
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftSetup(setupData: *const clfftSetupData) -> clfftStatus;
}
extern "C" {
    /*  @brief Release all internal resources.
	 *  @details Called when client is done with the FFT library, allowing the library to destroy all resources it has cached
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftTeardown() -> clfftStatus;
}
extern "C" {
    /*  @brief Query the FFT library for version information
	 *  @details Returns the major, minor and patch version numbers associated with the FFT library
	 *  @param[out] major Major functionality change
	 *  @param[out] minor Minor functionality change
	 *  @param[out] patch Bug fixes, documentation changes, no new features introduced
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftGetVersion(major: *mut cl_uint, minor: *mut cl_uint,
                           patch: *mut cl_uint) -> clfftStatus;
}
extern "C" {
    /*  @brief Create a plan object initialized entirely with default values.
	 *  @details A plan is a repository of state for calculating FFT's.  Allows the runtime to pre-calculate kernels, programs
	 * 	and buffers and associate them with buffers of specified dimensions.
	 *  @param[out] plHandle Handle to the newly created plan
	 *  @param[in] context Client is responsible for providing an OpenCL context for the plan
	 *  @param[in] dim Dimensionality of the FFT transform; describes how many elements are in the array
	 *  @param[in] clLengths An array of length of size 'dim';  each array value describes the length of each dimension
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftCreateDefaultPlan(plHandle: *mut clfftPlanHandle,
                                  context: cl_context, dim: clfftDim,
                                  clLengths: *const usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Create a copy of an existing plan.
	 *  @details This API allows a client to create a new plan based upon an existing plan.  This function can be used to
	 *  quickly create plans that are similar, but may differ slightly.
	 *  @param[out] out_plHandle Handle to the newly created plan that is based on in_plHandle
	 *  @param[in] new_context Client is responsible for providing a new context for the new plan
	 *  @param[in] in_plHandle Handle to a previously created plan that is to be copied
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftCopyPlan(out_plHandle: *mut clfftPlanHandle,
                         new_context: cl_context,
                         in_plHandle: clfftPlanHandle) -> clfftStatus;
}
extern "C" {
    /*  @brief Prepare the plan for execution.
	 *  @details After all plan parameters are set, the client has the option of 'baking' the plan, which informs the runtime that
	 *  no more change to the parameters of the plan is expected, and the OpenCL kernels can be compiled.  This optional function
	 *  allows the client application to perform the OpenCL kernel compilation when the application is initialized instead of during the first
	 *  execution.
	 *  At this point, the clfft runtime applies all implimented optimizations, including
	 *  running kernel experiments on the devices in the plan context.
	 *  <p>  This function takes a long time to execute. If a plan is not baked before being executed,
	 *  the first call to clfftEnqueueTransform takes a long time to execute.
	 *  <p>  If any significant parameter of a plan is changed after the plan is baked (by a subsequent call to any one of
	 *  the functions that has the prefix "clfftSetPlan"), it is not considered an error.  Instead, the plan reverts back to
	 *  the unbaked state, discarding the benefits of the baking operation.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] numQueues Number of command queues in commQueueFFT; 0 is a valid value, in which case the client does not want
	 * 	the runtime to run load experiments and only pre-calculate state information
	 *  @param[in] commQueueFFT An array of cl_command_queues created by the client; the command queues must be a proper subset of
	 * 	the devices included in the plan context
	 *  @param[in] pfn_notify A function pointer to a notification routine. The notification routine is a callback function that
	 *  an application can register and is called when the program executable is built (successfully or unsuccessfully).
	 *  Currently, this parameter MUST be NULL or nullptr.
	 *  @param[in] user_data Passed as an argument when pfn_notify is called.
	 *  Currently, this parameter MUST be NULL or nullptr.
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftBakePlan(plHandle: clfftPlanHandle, numQueues: cl_uint,
                         commQueueFFT: *mut cl_command_queue,
                         pfn_notify:
                             ::std::option::Option<unsafe extern "C" fn(plHandle:
                                                                            clfftPlanHandle,
                                                                        user_data:
                                                                            *mut ::std::os::raw::c_void)>,
                         user_data: *mut ::std::os::raw::c_void)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Release the resources of a plan.
	 *  @details A plan may include resources, such as kernels, programs, and buffers that consume memory.  When a plan
	 *  is no more needed, the client must release the plan.
	 *  @param[in,out] plHandle Handle to a previously created plan
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftDestroyPlan(plHandle: *mut clfftPlanHandle) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the OpenCL context of a previously created plan.
	 *  @details The user must pass a reference to a cl_context variable, which is modified to point to a
	 *  context set in the specified plan.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] context Reference to the user allocated cl_context, which points to context set in the plan
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftGetPlanContext(plHandle: clfftPlanHandle,
                               context: *mut cl_context) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the floating point precision of the FFT data
	 *  @details The user must pass a reference to a clfftPrecision variable, which is set to the
	 *  precision of the FFT complex data in the plan.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] precision Reference to the user clfftPrecision enum
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftGetPlanPrecision(plHandle: clfftPlanHandle,
                                 precision: *mut clfftPrecision)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Set the floating point precision of the FFT data
	 *  @details Sets the floating point precision of the FFT complex data in the plan.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] precision Reference to the user clfftPrecision enum
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftSetPlanPrecision(plHandle: clfftPlanHandle,
                                 precision: clfftPrecision) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the scaling factor that is applied to the FFT data
	 *  @details The user must pass a reference to a cl_float variable, which is set to the
	 *  floating point scaling factor that is multiplied across the FFT data.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dir Direction of the applied scaling factor
	 *  @param[out] scale Reference to the user cl_float variable
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftGetPlanScale(plHandle: clfftPlanHandle, dir: clfftDirection,
                             scale: *mut cl_float) -> clfftStatus;
}
extern "C" {
    /*  @brief Set the scaling factor that is applied to the FFT data
	 *  @details Sets the floating point scaling factor that is
	 *  multiplied across the FFT data.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dir Direction of the applied scaling factor
	 *  @param[in] scale Reference to the user cl_float variable
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftSetPlanScale(plHandle: clfftPlanHandle, dir: clfftDirection,
                             scale: cl_float) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the number of discrete arrays that the plan can concurrently handle
	 *  @details The user must pass a reference to a cl_uint variable, which is set to the
	 *  number of discrete arrays (1D or 2D) that is batched together for the plan
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] batchSize Number of discrete FFTs performed
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftGetPlanBatchSize(plHandle: clfftPlanHandle,
                                 batchSize: *mut usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Set the number of discrete arrays that the plan can concurrently handle
	 *  @details Sets the plan property which sets the number of discrete arrays (1D or 2D)
	 *  that is batched together for the plan
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] batchSize Number of discrete FFTs performed
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftSetPlanBatchSize(plHandle: clfftPlanHandle, batchSize: usize)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the dimensionality of the data that is transformed
	 *  @details Queries a plan object and retrieves the value of the dimensionality that the plan is set for.  A size is returned to
	 *  help the client allocate sufficient storage to hold the dimensions in a further call to clfftGetPlanLength
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] dim The dimensionality of the FFT to be transformed
	 *  @param[out] size Value to allocate an array to hold the FFT dimensions.
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftGetPlanDim(plHandle: clfftPlanHandle, dim: *mut clfftDim,
                           size: *mut cl_uint) -> clfftStatus;
}
extern "C" {
    /*  @brief Set the dimensionality of the data that is transformed
	 *  @details Set the dimensionality of the data that is transformed by the plan
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dim The dimensionality of the FFT to be transformed
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftSetPlanDim(plHandle: clfftPlanHandle, dim: clfftDim)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the length of each dimension of the FFT
	 *  @details The user must pass a reference to a size_t array, which is set to the
	 *  length of each discrete dimension of the FFT
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dim Dimension of the FFT; describes how many elements are in the clLengths array
	 *  @param[out] clLengths An array of length of size 'dim';  each array value describes the length of each dimension
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftGetPlanLength(plHandle: clfftPlanHandle, dim: clfftDim,
                              clLengths: *mut usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Set the length of each dimension of the FFT
	 *  @details Sets the plan property which is the length of each discrete dimension of the FFT
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dim The dimension of the FFT; describes how many elements are in the clLengths array
	 *  @param[in] clLengths An array of length of size 'dim';  each array value describes the length of each dimension
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftSetPlanLength(plHandle: clfftPlanHandle, dim: clfftDim,
                              clLengths: *const usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the distance between consecutive elements of input buffers in each dimension.
	 *  @details Depending on how the dimension is set in the plan (for 2D or 3D FFT), strideY or strideZ can be safely
	 *  ignored
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dim The dimension of the stride parameters; provides the number of elements in the array
	 *  @param[out] clStrides An array of strides, of size 'dim'.
	 */
    pub fn clfftGetPlanInStride(plHandle: clfftPlanHandle, dim: clfftDim,
                                clStrides: *mut usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Set the distance between consecutive elements of input buffers in each dimension.
	 *  @details Set the plan properties which is the distance between elements in all dimensions of the input buffer
	 *  (units are in terms of clfftPrecision)
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dim The dimension of the stride parameters; provides the number of elements in the clStrides array
	 *  @param[in] clStrides An array of strides of size 'dim'. Usually, strideX=1 so that successive elements in the first dimension are stored contiguously.
	 * 	Typically, strideY=LenX and strideZ=LenX*LenY with the successive elements in the second and third dimensions stored in packed format.
	 *  See  @ref DistanceStridesandPitches for details.
	 */
    pub fn clfftSetPlanInStride(plHandle: clfftPlanHandle, dim: clfftDim,
                                clStrides: *mut usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the distance between consecutive elements of output buffers in each dimension.
	 *  @details Depending on how the dimension is set in the plan (for 2D or 3D FFT), strideY or strideZ can be safely
	 *  ignored
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dim The dimension of the stride parameters; provides the number of elements in the clStrides array
	 *  @param[out] clStrides An array of strides, of size 'dim'.
	 */
    pub fn clfftGetPlanOutStride(plHandle: clfftPlanHandle, dim: clfftDim,
                                 clStrides: *mut usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Set the distance between consecutive elements of output buffers in a dimension.
	 *  @details Sets the plan properties which is the distance between elements in all dimensions of the output buffer
	 *  (units are in terms of clfftPrecision)
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dim The dimension of the stride parameters; provides the number of elements in the clStrides array
	 *  @param[in] clStrides An array of strides of size 'dim'.  Usually, strideX=1 so that successive elements in the first dimension are stored contiguously.
	 * 	Typically, strideY=LenX and strideZ=LenX*LenY cause the successive elements in the second and third dimensions be stored in packed format.
	 *  @sa clfftSetPlanInStride
	 */
    pub fn clfftSetPlanOutStride(plHandle: clfftPlanHandle, dim: clfftDim,
                                 clStrides: *mut usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the distance between array objects
	 *  @details Pitch is the distance between each discrete array object in an FFT array. This is only used
	 *  for 'array' dimensions in clfftDim; see clfftSetPlanDimension (units are in terms of clfftPrecision)
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] iDist The distance between the beginning elements of the discrete array objects in input buffer.
	 *  For contiguous arrays in memory, iDist=(strideX*strideY*strideZ)
	 *  @param[out] oDist The distance between the beginning elements of the discrete array objects in output buffer.
	 *  For contiguous arrays in memory, oDist=(strideX*strideY*strideZ)
	 */
    pub fn clfftGetPlanDistance(plHandle: clfftPlanHandle, iDist: *mut usize,
                                oDist: *mut usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Set the distance between array objects
	 *  @details Pitch is the distance between each discrete array object in an FFT array. This is only used
	 *  for 'array' dimensions in clfftDim; see clfftSetPlanDimension (units are in terms of clfftPrecision)
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] iDist The distance between the beginning elements of the discrete array objects in input buffer.
	 *  For contiguous arrays in memory, iDist=(strideX*strideY*strideZ)
	 *  @param[out] oDist The distance between the beginning elements of the discrete array objects in output buffer.
	 *  For contiguous arrays in memory, oDist=(strideX*strideY*strideZ)
	 */
    pub fn clfftSetPlanDistance(plHandle: clfftPlanHandle, iDist: usize,
                                oDist: usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the expected layout of the input and output buffers
	 *  @details Input and output buffers can be filled with either Hermitian, complex, or real numbers.  Complex numbers are stored
	 *  in various layouts; this function retrieves the layouts used by input and output
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] iLayout Indicates how the input buffers are laid out in memory
	 *  @param[out] oLayout Indicates how the output buffers are laid out in memory
	 */
    pub fn clfftGetLayout(plHandle: clfftPlanHandle,
                          iLayout: *mut clfftLayout,
                          oLayout: *mut clfftLayout) -> clfftStatus;
}
extern "C" {
    /*  @brief Set the expected layout of the input and output buffers
	 *  @details Input and output buffers can be filled with either Hermitian, complex, or real numbers.  Complex numbers can be stored
	 *  in various layouts; this function informs the library what layouts to use for input and output
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] iLayout Indicates how the input buffers are laid out in memory
	 *  @param[in] oLayout Indicates how the output buffers are laid out in memory
	 */
    pub fn clfftSetLayout(plHandle: clfftPlanHandle, iLayout: clfftLayout,
                          oLayout: clfftLayout) -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve whether the input buffers are to be overwritten with results
	 *  @details If the setting performs an in-place transform, the input buffers are overwritten with the results of the
	 *  transform.  If the setting performs an out-of-place transforms, the library looks for separate output buffers
	 *  on the Enqueue call.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] placeness Informs the library to either overwrite the input buffers with results or to write them in separate output buffers
	 */
    pub fn clfftGetResultLocation(plHandle: clfftPlanHandle,
                                  placeness: *mut clfftResultLocation)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Set whether the input buffers are to be overwritten with results
	 *  @details If the setting performs an in-place transform, the input buffers are overwritten with the results of the
	 *  transform.  If the setting performs an out-of-place transforms, the library looks for separate output buffers
	 *  on the Enqueue call.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] placeness Informs the library to either overwrite the input buffers with results or to write them in separate output buffers
	 */
    pub fn clfftSetResultLocation(plHandle: clfftPlanHandle,
                                  placeness: clfftResultLocation)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Retrieve the final transpose setting of a multi-dimensional FFT
	 *  @details A multi-dimensional FFT transposes the data several times during calculation. If the client
	 *  does not care about the final transpose, to put data back in proper dimension, the final transpose can be skipped
	 *  to improve speed
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] transposed Specifies whether the final transpose can be skipped
	 */
    pub fn clfftGetPlanTransposeResult(plHandle: clfftPlanHandle,
                                       transposed: *mut clfftResultTransposed)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Set the final transpose setting of a multi-dimensional FFT
	 *  @details A multi-dimensional FFT transposes the data several times during calculation.  If the client
	 *  does not care about the final transpose, to put data back in proper dimension, the final transpose can be skipped
	 *  to improve speed
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] transposed Specifies whether the final transpose can be skipped
	 */
    pub fn clfftSetPlanTransposeResult(plHandle: clfftPlanHandle,
                                       transposed: clfftResultTransposed)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Get buffer size (in bytes), which may be needed internally for an intermediate buffer
	 *  @details Very large FFT transforms may need multiple passes, and the operation needs a temporary buffer to hold
	 *  intermediate results. This function is only valid after the plan is baked, otherwise, an invalid operation error
	 *  is returned. If the returned buffersize is 0, the runtime needs no temporary buffer.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[out] buffersize Size in bytes for intermediate buffer
	 */
    pub fn clfftGetTmpBufSize(plHandle: clfftPlanHandle,
                              buffersize: *mut usize) -> clfftStatus;
}
extern "C" {
    /*  @brief Register the callback parameters
	 *  @details Client can provide a callback function to do custom processing while reading input data and/or
	 *  writing output data. The callback function is provided as a string.
	 *  clFFT library incorporates the callback function string into the main FFT kernel. This function is used
	 *  by client to set the necessary parameters for callback
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] funcName Callback function name
	 *  @param[in] funcString Callback function in string form
	 *  @param[in] localMemSize Optional - Size (bytes) of the local memory used by callback function; pass 0 if no local memory is used
	 *  @param[in] callbackType Type of callback - Pre-Callback or Post-Callback
	 *  @param[in] userdata Supplementary data if any used by callback function
	 *  @param[in] numUserdataBuffers Number of userdata buffers
	 */
    pub fn clfftSetPlanCallback(plHandle: clfftPlanHandle,
                                funcName: *const ::std::os::raw::c_char,
                                funcString: *const ::std::os::raw::c_char,
                                localMemSize: ::std::os::raw::c_int,
                                callbackType: clfftCallbackType,
                                userdata: *mut cl_mem,
                                numUserdataBuffers: ::std::os::raw::c_int)
     -> clfftStatus;
}
extern "C" {
    /*  @brief Enqueue an FFT transform operation, and return immediately (non-blocking)
	 *  @details This transform API function computes the FFT transform. It is non-blocking as it
	 *  only enqueues the OpenCL kernels for execution. The synchronization step must be managed by the user.
	 *  @param[in] plHandle Handle to a previously created plan
	 *  @param[in] dir Forward or backward transform
	 *  @param[in] numQueuesAndEvents Number of command queues in commQueues; number of expected events to be returned in outEvents
	 *  @param[in] commQueues An array of cl_command_queues created by the client; the command queues must be a proper subset of
	 * 	the devices included in the OpenCL context associated with the plan
	 *  @param[in] numWaitEvents Specify the number of elements in the eventWaitList array
	 *  @param[in] waitEvents Events for which the transform waits to complete before executing on the device
	 *  @param[out] outEvents The runtime fills this array with events corresponding one to one with the input command queues passed
	 *	in commQueues.  This parameter can have the value NULL or nullptr. When the value is NULL, the client is not interested in receiving notifications
	 *	when transforms are finished, otherwise, (if not NULL) the client is responsible for allocating this array with at least
	 *	as many elements as specified in numQueuesAndEvents.
	 *  @param[in] inputBuffers An array of cl_mem objects that contain data for processing by the FFT runtime. If the transform
	 *  is in-place, the FFT results overwrite the input buffers
	 *  @param[out] outputBuffers An array of cl_mem objects that store the results of out-of-place transforms. If the transform
	 *  is in-place, this parameter may be NULL or nullptr and is completely ignored
	 *  @param[in] tmpBuffer A cl_mem object that is reserved as a temporary buffer for FFT processing. If clTmpBuffers is NULL or nullptr,
	 *  and the library needs temporary storage, an internal temporary buffer is created on the fly managed by the library.
	 *  @return Enum describing error condition; superset of OpenCL error codes
	 */
    pub fn clfftEnqueueTransform(plHandle: clfftPlanHandle,
                                 dir: clfftDirection,
                                 numQueuesAndEvents: cl_uint,
                                 commQueues: *mut cl_command_queue,
                                 numWaitEvents: cl_uint,
                                 waitEvents: *const cl_event,
                                 outEvents: *mut cl_event,
                                 inputBuffers: *mut cl_mem,
                                 outputBuffers: *mut cl_mem,
                                 tmpBuffer: cl_mem) -> clfftStatus;
}
